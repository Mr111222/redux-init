 js

	1.闭包
		底层:栈 函数执行完毕栈不回收
		高层:函数当做对象去处理
	2.正则
		search 返回时数字
		match 返回你所匹配的东西

	3.call, apply的使用
		function sum(num1, num2){
      if(num1 && num2) return num1 + num2;
      else return num1
    }
    function callSum1(num1, num2){
        return sum.apply(this, arguments);
    }
    function callSum2(num1, num2){
      let names="pps"
        return sum.call(this,names);
    }

    alert(callSum1(10,10));   //20
    alert(callSum2(10,10));   //20


4.事实上，传递参数并非 apply()和 call()真正的用武之地;它们真正强大的地方是能够扩充函数 赖以运行的作用域。下面来看一个例子。
    window.color = "red";
		var o = { color: "blue" };
		function sayColor(){
		    alert(this.color);
		}
		sayColor();	// red
		sayColor.call(this);	// red
		sayColor.call(window);	//red
		sayColor.call(o);	//blue
5.substring
		slice()第一个参数指定子字 符串的开始位置，第二个参数(在指定的情况下)表示子字符串到哪里结束。
		substring()第一个参数指定子字 符串的开始位置，第二个参数(在指定的情况下)字符串最后一个字符的位置。
		substr()第二个参数指定的是要返回的字符个数
6.beforeRoute Update(to, from, next){
	this.update(to.parmas.id) // 调用方法更新id对应的组件更新
	next()
}

koa 

const Koa = require('koa')

const server = new Koa()

const static = require('koa-static')

const body = require('koa-better-body')  // 获取所有地址栏的参数(get, post , all)

const session = require('koa-session')

const mysql = require('mysql')

const co = require('co-mysql')

// 容错处理 也 可以在路由处进行处理
server.use(async (ctx,next)=>{
	try{	
		await next()
	}catch(e){
		ctx.body = 'database is error'
	}
})
//-------------------------- 
server.listen(8080)

server.context.a = 12  // 一般用于定义去全局变量

let router = new Router()

// ----------------------------
ctx.throw(状态码, 错误信息)
router.get('/login' async ctx=>{
	ctx.throw(400, 'use passwoed is required')
})


ctx.assert 断言测试
ctx.assert(条件,状态码,描述信息)
router.get('/login' async ctx=>{
	ctx.assert(ctx.query.use, 400, 'use is required')
	ctx.assert(ctx.query.password, 400, 'password is required')
})


ctx.state = 305
router.get('/cartoon' async ctx=>{
	ctx.state = 404
})

ctx.redirect() // 重定向成功跳转
router.get('/login' async ctx=>{
	ctx.redirect('/mews')
})

ctx.attchment()
router.get('/login' async ctx=>{
	ctx.attchment('/a.txt') // 文件路径
})



// ----------------------------
// koa-static
let staticRouter= new Router() // 静态路由

staticRouter.all(/(\.png | \.jpg | \.gif)$/i, {
	maxage: 1000*86400*60
})


staticRouter.all(/(\.css | \.scss | \.less)$/i, {
	maxage: 1000*86400*1
})

// ----------------------------
// koa-better-body
1.上传文件
server.use(body,({
	uploadDir: './static/upload'  //上传文件存放的路径
}))

server.use(async ctx=>{
	cosnole.log(ctx.request.fields)
})
// ----------------------------
// cookie

server.use(async ctx=>{
	ctx.cookie.set('user', 'pps', {
		maxage: 1000*86400*1, // 过期时间
		signed: true // 签名
	}) 
	// 设置 cookie 
	ctx.cookie.get('user') 
	// 获取cookie
})
// ----------------------------
// session  koa-session
server.keys = ['asdasda','21123123','2saawsw23f']
server.use(session,({
	maxAge:20*60*1000,
	renew: true// 自动续期
}, server))

server.use(async ctx=>{
 if(!.session['view']){
	.session['view'] = 0
  }else{
	.session['view']++
	ctx.body = `这是第${ctx.session.view}访问`
 }
})
// ----------------------------
// 连接 mysql
let conn = mysql.createPool({
	host:'localhost',
	user:'root',
	password: '',
	database: ''
})

let db = co(conn)

server.context.db = db

server.use(async ctx=>{
	let data = await db.query(`SELECT * FROM item_table`)
	ctx.body = data
})

// ----------------------------
// const fs = require('await-fs') // koa 读取文件使用
	
// ----------------------------
// koa 接受数据 完成post提交
	const {title, name, age } = ctx.request.files //获得参数
	// add

	ctx.db.query('INSERT INTO class_tab (title, name, age) VALUES(?,?,?)',[title, name, age])
	router.post('/banner',async ctx=>{
		const {title, name, age} = ctx.request.files
		await ctx.db.query('INSERT INFO class_tab (title, name, age) VALUES (?,?,?)', [title, name, age])
		ctx.redirect('/admin')
	})

	// del 
	router.get('/banner/del/:id', async ctx=>{
		const {id} = ctx.parmas
		let data = await ctx.db.query(`SELECT * FROM WHERE id=${id}`)
		let {filename} = data.json()
		unlinkFn(`../../updata/${filename}`)
		ctx.db.query('DELETE class_tab WHERE id=?',[id])
		ctx.db.redirect('./admin')
	})

	// update
	// UPDATE class_tab SET title="xx", WHERE id='1'
	router.get('/banner/mod/:id/', async ctx=>{
		let {id} = ctx.parmas
		let data = ctx.db.query('SELECT * FROM class_tab WHERE id=?',[id])
		ctx.assert(data.length<0, 400, 'no data') 
	})



	function unlinkFn(path){
		return new Promise((resolve,reject)=>{
			fs.unlink(path,(err)=>{
				if(err){
					reject(err)
				}else{
					resolve()
				}
			})
		})
	}




server.use(router.Routes())
server.use(staticRouter.Routes())





// webpack 配置多入口
webpack.config.js
const path = requier('path')
module.exports = {
	mode: 'development',
	evtry:{
		index: './src/main1.js',
		admin: './src/main2.js'
	},
	output:{
		path: path.resolve(__dirname, 'boundle'),
		filename: [name].min.js
	},

	// css-loader  配置启用模块化

	module:{
		rules:[
			{test:'/\.css$/', use:['style-loader', 'css-loader?modules']}
		]
	}
}



// 单元测试   npm jest jest-webpacl -D 
// 
// http 协议 

HTTP 1.0 RFC-1945
HTTP 1.1 RFC-2616  持久连接
HTTPS 	 RFC-2818	 安全协议
HTTP 2.0 RFC-7540		加密，头部压缩，服务器推送，管线操作，多路复用

http 报文结构
	header	<=32k
	body 		<=2G

状态码
	1xx 信息
	2xx 成功
	3xx 重定向
	4xx 请求错误 客户端
	5xx 服务器错误 服务端

请求方式
	get, post, del, put

	get 	获取
		数据放到url里面传输，容量较小
	post 	向服务器发送数据
		容量较大

接收浏览器发送来的GET数据
	const http = require('http')
	const url = require('url')
	const server = http.createServer(function(req, res){
		let {pathname, query} = url.parse(req.url, true)
	})
	server.listen(8080)

接收浏览器发送来的POST数据
	分几次发送数据，所以需要用数据进行连接并最后处理
	const http = require('http')
	const url = require('url')
	const querystring = require('querystring')
	const server = http.createServer(function(req, res){
		let arr = []
		req.on('data', buffer=>{
			console.log(buffer)
			arr.push(buffer)
		})
		req.on('end', ()=>{
			let res = Buffer.concat(arr) // Buffer 为Buffer对象
			let result = querystring.parse(res.toString())
			console.log(result)
		})
	})
	server.listen(8080)


sever_total.js   同时获取数据 post,get
	const http = reuqire('http')
	const url = require('url')
	const querystring = require('querystring')
	const fs = require('fs')

	const server = http.createServer((req, res)=>{
		let path = ''
		let get = {}
		let post = {}
		let userJson = {}
		if(req.methods == 'GET') {
			let {pathname, query} = url.parse(req.url, true)
			path = pathname
			get = query
		}else if(req.methods == 'POST'){
			let arr = []
			path = req.url
			let {pathname, query} =
			req.on('data',(buffer)=>{
				arr.push(buffer)
			})
			req.on('end', ()=>{
				let result = Buffer.cancat(arr)
				post = querystring.parse(result.toString())
			})
		}
		function complite () {
			if(path == '/reg'){
				let {user, pass} = get
				if(userJson[user]){
					res.write(JSON.stringify({err:1, msg: '用户已存在'})）
					res.end()
				}else{
					res.write(JSON.stringify({err:0, msg: '注册成功'})）
					res.end()
				}
			}else if(path == '/login'){
				let {user, pass} = get
				if(!userJson[user]){
					res.write(JSON.stringify({err:1, msg: '找不到用户'})）
					res.end()
				}else if(userJson[user] ){
					res.write(JSON.stringify({err:0, msg: '注册成功'})）
					res.end()
				}
			}
		}
	}).listen(9090)

断言测试
	const assert = require('assert')
	assert(5<3, '不对') // 条件  报错信息
Buffer对象
 let buf = new Buffer('abcdefg')
 buf.splice(0,3)   ---->  abc



	
let htmlWidth = document.documentElement.clientWidth || document.body.clientWidth
let htmlDom = document.getElementByTagName('html')[0]
htmlDom.style.fontSize = htmlWidth/20+'px'






Typescript



vscode 自动生成js代码
	1.生成 tsconfig.json   tsc --init 改outDir
	2.任务 运行任务 监视 tsconfig.json

	hbuilder 编辑器 自己配置

数据类型
	必须指定类型
	var flag:boolean = true
			flag = 123   // error
			flag = false // success
	var num:number = 123 
	var arr:[number, string] = [123, 'cc']	// 元祖类型

	// 枚举类型
	enum flag{success=1, error=0}

	let f:flag = flag.success

	enum Color{pink, blue, red}
	var c:Color = Color.red // 2 无值状态显示下标

	enum Err{success=1, error=2, null=3}
	var e:Err = Err.null	 // 3


任意类型  any

	var num:any = 123
			num = 'cc'
			num = boolean
			num = [1,2,3]

	用处：

	var box:any = document.getElementById('box')
		box.style.color = 'red'
	
	null, undefined
	var num:null;
			num = 3

	定义不确定变量类型

	var pps:number | null | undefined;

void 类型
		1.表示没有任意类型，没有返回值的时候
			function run(x):void{
				console.log(x)  // 无返回值
			}
		2. 有返回值
			function run ():number {
				return 123
			}

never类型(包括null,undefined),表示从不会出现的值  一般很少用到

函数应用
	普通js
	function run () {
		console.log(12)
	}

	ts
	函数声明
	function run():string{
		return 'xxx'
	}
	函数表达式
	var run = function():string{
		return '123'
	}

	传参
	function run(age:number, name:string):string{
		return `${age}+${name}`
	}

	可选参数 在可选参数上添加？表示为可选  
	***可选参数必须配置到参数的最后
		run(age:number, name?:string) //seccess
		run(age?:number, name:string) // false 会报错   修改为--->run(age:number, name?:string)
	***
	function run(age:number, name?:string):string{
		return `${age}+${name}`
	}
	设置默认参数
	function run(age:number = 12, name:string):string{
		return `${age}+${name}`
	}
	剩余参数
	function sum(a:number, b:number, c:number, d:number){
		return a+b+c+d
	}
	sum(1,2,3,4)
	// 三点运算符 ...sum
	function sum(...result:numer[]):number{
			// 遍历 result
			// 相加
			// return 返回
	}
	sum(1,2,3,4)

	方法重载
	function get(name:string):string;
	function get(age:number):number;
	function get(str:any):any{
		if(typeof str === 'string'){
			// code...
		}else if(typeof age === 'number'){
			// code ...
		}
	}

	箭头函数
	setTimeout(function(){
		alert(12)
	},1000)

	setTimeout(()=>{
		alert(12)
	},1000)


	定义类

	跟es6集成没多大区别，只是定义变量加上数据类型而已

	定义接口
		interface FullName () {
			firstName:string; // 分号结尾
			secondName:string;
		}

		function getName (name:FullName) {
			console.log(name.firstName)
		}

		调用：getName({
			firstName:'zhang',
			secondName:'san'
		})



	可选属性
		interface FullName () {
			firstName:string; // 分号结尾
			secondName?:string; // 加个？ 作为可传或者不传
		}

		function getName (name:FullName) {
			console.log(name.firstName)
		}

		调用：getName({
			firstName:'zhang',
			secondName:'san'
		})


		eg:
			interface Config{
				type:string;
				url:string;
				data?:string;
				dataType:string;
			}
		function ajax (config:Config) {
			$.ajax({
				url:config.url
				type:config.type,
				data:config.data,
				dataType:config.dataType
			})
		}

		ajax({
			url:"wwww.baidu",
			type: 'get',
			dataType:'json',  
		})

	类接口

	interface Animal{  // 约束条件， 必须有name属性和eat方法
		name:string;
		eat(str:string):void
	}

	class Dog implements Animal {
		name:string;
		constructor(name:string){
			this.name = name
		}
		eat(){
			console.log(`${this.name}吃粮食`)
		}
	}

	class Cat implements Animal {
		name:string;
		constructor(name:string){
			this.name = name
		}
		eat(food){
			console.log(`${this.name}吃${food}`)
		}
	}

	var d = new Dog('小黑')
			d.eat() // 小黑吃粮食
	var c = new Cat('小花')
			c.eat('老鼠')


	接口扩展   接口继承接口


	interface Animal {
		eat():void;
	}

	interface Persion extends Animal{ // Persion 继承 animal接口
		work():void;
	}

	class Web implements Persion{
		public name:string;
		constructor(name:string){
			this.name = name
		}
		eat(){
			cosnole.log(`我叫${this.name}`)
		}
		work(job:string){
			console.log(`我的工作是${this.job}`)
		}
	}


	interface Animal { // 定义接口
  eat():void;
}

interface Persion extends Animal{ // Persion 继承 animal接口
  work(jon:string):void;
}


class Programmer{
  public name:string;
  constructor(name:string){
    this.name = name
  }
  coding(job:string){
    console.log(`${this.name}${job}--->继承与Programmer--->coading方法`)
  }
}

class Web extends Programmer implements Persion{  // 创建接口 并且继承Programmer父类
  constructor(name:string){
    super(name)
  }
  eat(){
    console.log(`我叫${this.name}`)
  }
  work(job:string){
    console.log(`${this.name}的工作是${job}`)
  }

  // eat work 方法需要看他的接口怎么定义，且必须要定义
}

var p = new Web('小刚')
  p.eat()
  p.work('敲代码')
  p.coding('敲ts代码')





泛型

// 定义
function getData<T>(value:T):T{
	return value
}
//	调用
getData<number>(123)  // ok
getDate<string>(123)	// error    getDate<string>('123')

泛型类定义

class minCls<T>{
	public list:T[] = []

	add (num:T):void{
		this.list.push(num)
	}

	min():T{
		let arr = this.list[0]
		for(var i=0;i<this.list.length; i++){
			if(arr>this.list[i]){
				arr = this.list[i]
			}
		}
		return arr
	}
}

var p1 = new minCls<number>() // 实例化对象，并制定泛型T的类型为number
p1.add(1)
p1.add(2)
p1.add(3)
console.log(p1.min())

var p2 = new minCls<string>()
p2.add('a')
p2.add('z')
p2.add('x')
console.log(p2.min()) 



/*
  1.msq, mqdbsql, mogodb定义接口 包含 add, get, del ,updata 方法
  2.代码重用
*/  

interface DBI<T>{ // 由于参数不确定，所以设定为泛型接口
  add(info:T):boolean
  del(info:T, id:number):boolean
  updata(id:number):boolean
  get(id:number):any[]
}

//要实现泛型接口，这个类也是泛型类
class msq<T> implements DBI<T>{
  constructor(){
    console.log(`与数据库建立连接`)
  }
  add(info:T):boolean{
    console.log(info)
    return true
    // throw new Error('is error')
  }
  del(info:T, id:number):boolean{
    if(id == 2){
      console.log(`已删除`)
    }
    return true
  }
  updata(id:number):boolean{
    if(id == 3){
      console.log(`已更新`)
    }
    return true
  }
  get(id:number):any[]{
    var list = [{
      err:0,
      msg:'success',
      data:'<div><p>呵呵</p></div>'
    }]
    return list
  }
}


class dbsql<T> implements DBI<T>{
  add(info:T):boolean{
    throw new Error('is error')
  }
  del(info:T, id:number):boolean{
    throw new Error('is error')
  }
  updata(id:number):boolean{
    throw new Error('is error')
  }
  get(id:number):any[]{
    throw new Error('is error')
  }
}

class mogodb<T> implements DBI<T>{
  add(info:T):boolean{
    throw new Error('is error')
  }
  del(info:T, id:number):boolean{
    throw new Error('is error')
  }
  updata(id:number):boolean{
    throw new Error('is error')
  }
  get(id:number):any[]{
    throw new Error('is error')
  }
}


// 操作用户表  创建user类

class admin{  // 约束
  name:string|undefined
  pass:string|undefined
}

var admins = new admin()
    admins.name = 'blue'
    admins.pass = '123'


var mq = new msq<admin>() // 在这里调用约束
  // mq.add(admins)
  // mq.del(admins,2)
  // mq.updata(3)
  // console.log(mq.get(2), '获取的数据')

// import {dbUrl, getData} from './modules/db'     // TS本身不支持，需要webpack支持export 和 import
// console.log(dbUrl)
// 
// 
// 

// import {dbUrl, getData} from './modules/db'     // TS本身不支持，需要webpack支持export 和 import
// console.log(dbUrl)

// 装饰器 一种特殊的声明， 可以注入到类，方法，属性上面

function logClass(arg:any){
  // arg  当前类
  arg.prototype.name = 'xxxx'
  arg.prototype.run = function(){
    console.log(`我是run方法`)
  }
}

// @logClass
// class zhuFn{
//   constructor(){

//   }
// }

// var zhu = new zhuFn()
// console.log(zhu.name) // 动太扩展的属性
// zhu.run()

// 装饰器 (可传参)

function logclass1 (arg:string) {
  return function(target:any){
    console.log(arg, target)
  }
}

@logClass1('heheh')
class zhu1{
  constructor(){
    
  }
}








 react

 class App extends React.Component{
 	constructor(...args){
 		super(...args)
 		this.state = {
 			name: 'xx'
 		}
 	}
 }  

 this.setState({
 	name: 'pps'
 }, function(){
 	console.log(this.state.mame)
 })
  // 添加个回调可以立即获取到这个修改的值

 cosnole.log(this.state.name)  // 不会是pps  而是xx

 // 因而 this.setStatus 是异步操作的，可能还没有执行完毕，就执行到最下面了
 // 
 // 
 // 
 // 
 

 typesceipt  在vue中使用

 配置loader ts-loader


 import {Component, Vue, Props} from 'vue-property-decorator'

 export default class Hello extends Vue{
 	
 }















 

